# fs2-quartz
Quarts scheduler library using fs2

### Import
```scala
libraryDependencies ++= Seq(
  "com.itv" %% "fs2-quartz-core"     % "0.6.3-SNAPSHOT",
  "com.itv" %% "fs2-quartz-extruder" % "0.6.3-SNAPSHOT"
)
```

The project uses a quartz scheduler, and as scheduled messages are generated by Quartz they are
decoded and put onto an `fs2.concurrent.Queue`. The components are:
* a `MessageScheduler[F[_], J, A]` which schedules and receives corresponding messages
* a `JobDataEncoder[J]` which encodes job data in a map for the given job
* a single job class (`PublishCallbackJob`) which is triggered by quartz when a scheduled task occurs
* a `JobDecoder[A]` which decodes the incoming message data map into an `A`
* the resulting `A` is put onto the provided `fs2.concurrent.Queue[F, A]`

*** Quite often `J` and `A` will be the same type, usually a parent sealed trait

## Usage:

## Create some job types
We need to have a set of types to encode and decode.
The [extruder](https://janstenpickle.github.io/extruder/) project provides the ability to
encode/decode an object as a `Map[String, String]`, which works perfectly for 
putting data into the quartz job data map.
```scala
import com.itv.scheduler.{JobDataEncoder, JobDecoder}
import com.itv.scheduler.extruder.implicits._
import extruder.core._
import extruder.map._

sealed trait ParentJob
case object ChildObjectJob     extends ParentJob
case class UserJob(id: String) extends ParentJob

object ParentJob {
  implicit val jobDataEncoder: JobDataEncoder[ParentJob] = deriveEncoder[ParentJob]
  implicit val jobDecoder: JobDecoder[ParentJob]         = deriveDecoder[ParentJob]
}
```

### Creating a scheduler
```scala
import java.util.concurrent.Executors
import cats.effect._
import com.itv.scheduler.{JobDecoder, MessageScheduler, QuartzProperties, QuartzTaskScheduler}
import com.itv.scheduler.extruder.implicits._
import extruder.map._
import scala.concurrent.ExecutionContext

implicit val contextShift: ContextShift[IO] = IO.contextShift(ExecutionContext.global)
// contextShift: ContextShift[IO] = cats.effect.internals.IOContextShift@9d94316

val quartzProperties = QuartzProperties(new java.util.Properties())
// quartzProperties: QuartzProperties = QuartzProperties({})
val blocker = Blocker.liftExecutorService(Executors.newFixedThreadPool(8))
// blocker: Blocker = cats.effect.Blocker@14fd58a9
val schedulerResource: Resource[IO, MessageScheduler[IO, ParentJob, ParentJob]] =
  QuartzTaskScheduler[IO, ParentJob, ParentJob](blocker, quartzProperties)
// schedulerResource: Resource[IO, MessageScheduler[IO, ParentJob, ParentJob]] = Allocate(
//   Map(
//     Bind(
//       Map(
//         Delay(cats.effect.concurrent.Ref$$$Lambda$5414/1030571423@34dba820),
//         scala.Function1$$Lambda$5422/1624867808@57d647de,
//         1
//       ),
//       com.itv.scheduler.QuartzTaskScheduler$$$Lambda$5423/1337265300@430f7522
//     ),
//     scala.Function1$$Lambda$5422/1624867808@6964cfa9,
//     1
//   )
// )
```

### Using the scheduler
```scala
import java.time.Instant
import com.itv.scheduler._
import org.quartz.{CronExpression, JobKey, TriggerKey}

def scheduleCronJob(scheduler: MessageScheduler[IO, ParentJob, ParentJob]): IO[Option[Instant]] =
  scheduler.scheduleJob(
    JobKey.jobKey("child-object-job"),
    ChildObjectJob,
    TriggerKey.triggerKey("cron-test-trigger"),
    CronScheduledJob(new CronExpression("* * * ? * *"))
  )

def scheduleSingleJob(scheduler: MessageScheduler[IO, ParentJob, ParentJob]): IO[Option[Instant]] =
  scheduler.scheduleJob(
    JobKey.jobKey("single-user-job"),
    UserJob("user-123"),
    TriggerKey.triggerKey("scheduled-single-test-trigger"),
    JobScheduledAt(Instant.now.plusSeconds(2))
  )
```
